---
{"dg-publish":true,"permalink":"/Linux/05.x64 Disassembly/","tags":["linux"]}
---


## CPU 寄存器

通常情况下，32位CPU寄存器（例如EAX）的名称被扩展为64位版本（例如RAX）。大多数寄存器传统上是专用的，例如算术逻辑单元（ALU）、计数器和内存复制寄存器。尽管如此，现在它们都可以作为通用寄存器使用。

还有一个堆栈指针 RSP，另外还有一个帧指针 RBP，用于寻址局部变量和保存的参数。它可用于回溯重建（backtrace reconstruction）。

在一些编译器代码生成实现中， `RBP` 也用作通用寄存器，具有 `RSP` 帧指针的作用。每次函数调用时， `RIP` 都会在堆栈内存区域中保存一个指令指针，然后在从调用的函数返回时恢复该指令指针。

除了这些寄存器之外，x64 平台还具有另外 8 个通用寄存器，从 `R8` 到 `R15` 。

![Pasted image 20240702101139.png](/img/user/Linux/assert/Pasted%20image%2020240702101139.png)

>注意：RAX寄存器是一个64位寄存器，其低32位包含EAX寄存器。32位EAX寄存器的低半部分包含16位的AX寄存器。16位的AX寄存器又分为上半部分的AH和下半部分的AL两个8位寄存器。

### 寄存器

下图显示了涉及寄存器操作的 CPU 指令的几个示例，例如移动值和执行算术运算。如果我们习惯于 Windows 上的 WinDbg，则操作数的方向与 Intel x64 反汇编风格相反。可以在 GDB 中使用 Intel 反汇编风格.

![Pasted image 20240702101319.png](/img/user/Linux/assert/Pasted%20image%2020240702101319.png)

## 内存和堆栈寻址

在查看内存操作之前，让我们先看一下内存寻址的图形表示。线程堆栈只是任何其他内存区域，因此可以使用任何其他寄存器来代替 `RSP` 和 `RBP` 。

>注意：堆栈会向较低的地址增长，因此要访问先前推送的值，我们需要使用来自 `RSP` 的正偏移量。

![Pasted image 20240702101436.png](/img/user/Linux/assert/Pasted%20image%2020240702101436.png)

### 内存加载

常量在指令中编码，但如果我们需要任意值，则必须从内存中获取它们。圆括号显示相对于存储在某个寄存器中的地址的内存访问。

![Pasted image 20240702101522.png](/img/user/Linux/assert/Pasted%20image%2020240702101522.png)
### 内存存储

存储类似于加载。

![Pasted image 20240702101622.png](/img/user/Linux/assert/Pasted%20image%2020240702101622.png)
### 控制流

Goto（无条件跳转）是通过 `JMP` 指令实现的。函数调用是通过指令实现的 `CALL` 。

>注意：对于条件分支，请查看官方文档。

![Pasted image 20240702101729.png](/img/user/Linux/assert/Pasted%20image%2020240702101729.png)

## 函数调用和函数 prolog

当从调用方调用函数时，被调用方需要执行某些操作，以便为线程堆栈上的局部变量腾出空间。有不同的方法可以做到这一点，左边的汇编语言代码就是其中之一。我们在右侧的图表中使用不同的颜色来突出显示调用之前 `proc2` 的更新 `RSP` 和 `RBP` 值。为了简单起见，我们只使用 64 位值。

![Pasted image 20240702101831.png](/img/user/Linux/assert/Pasted%20image%2020240702101831.png)

在64位x86架构中，前六个函数参数通常保存在寄存器 rdi、rsi、rdx、rcx、r8 和 r9 中。因此，在这个例子中：

1. 4位整数 p1 被保存在 edi 寄存器中（也就是 rdi 的低32位）。
2. 8位长的 p2 被保存在 rsi 寄存器中。

调用 proc 函数会将返回地址（在这个例子中是 addr）压入堆栈，并且控制权交给 proc 函数。

proc 函数的函数序言有以下三个步骤：

1. 保存调用者函数的基指针 RBP。这是 proc 中的第一条指令。
2. 设置新的基指针。这是 proc 中的第二条指令。
3. 为局部变量分配空间（在这个例子中是 8 位长的整数 local）。这通过从堆栈中减去 8 位来完成。

在函数序言之后，函数代码开始执行。因此，局部变量 local 初始化为0。

调用 proc2 会将返回地址（在这个例子中是 adr2）压入堆栈，从而更新 rsp。

## 堆栈回溯重建

在上图中，我们可能已经注意到，新的 `RBP` 指向调用方的地址 `RBP` ，而上 `RBP` 图下方是调用方的返回地址。

因此，如果我们知道该 `RBP` 值，如果编译器遵循上述函数的 prolog 约定，则可以重建堆栈跟踪。

![Pasted image 20240702102134.png](/img/user/Linux/assert/Pasted%20image%2020240702102134.png)