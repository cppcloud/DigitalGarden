---
{"dg-publish":true,"tags":["os"],"permalink":"/OS/异步IO模型/","dgPassFrontmatter":true}
---



## 同步和异步

**同步**和**异步**涉及消息通信机制，着重从调用者的角度出发。

+ 同步操作：要求发出调用后，必须等到操作完成并返回结果，过程中调用者无法执行其他任务。
+ 异步操作：允许发出调用后立即返回，调用者可以继续执行其他任务，操作结果通常通过状态、通知或回调来获取。

## 阻塞和非阻塞

**阻塞**和**非阻塞**则关注程序在等待调用结果时的状态，主要从被调用者的角度考虑。

+ 阻塞调用：使得执行操作的线程在等待操作完成期间无法执行其他任务，即线程挂起。
+ 非阻塞调用：允许线程在发起操作后继续执行，通过状态检查或在适当时再次尝试，来获取操作结果。

**阻塞，和系统调用有关。**
# IO 模型

![Pasted image 20240715070553.png](/img/user/OS/assert/Pasted%20image%2020240715070553.png)

# 同步阻塞 IO

![Pasted image 20240715070714.png](/img/user/OS/assert/Pasted%20image%2020240715070714.png)


### 输入操作两个阶段 ：

1.  进程等待内核将数据准备好，这个阶段可以阻塞也可以非阻塞，设置 socket 属性。
   + 阻塞：recvfrom 阻塞线程直到返回数据就绪的结果。
   + 非阻塞：立即返回一个错误，轮询直到数据就绪。
2. 从内核缓存区向进程缓存区复制数据。（一直阻塞）

异步 IO，recvfrom 总是立即返回，两个阶段都是内核完成。


# IO 多路复用

Io 多路复用是一种同步 IO 模型，实现一个线程可以监视多个文件句柄。
支持 IO 多路复用的系统调用有 select/pselect/poll/epoll, 本质都是同步 IO, 因为数据拷贝都是阻塞的，通过 select/epoll 来判断数据报是否准备好，即判断可读可写状态。


# Epoll

![Pasted image 20240715072018.png](/img/user/OS/assert/Pasted%20image%2020240715072018.png)

+ epoll_create (int size): 内核产生一个 epoll 实例数据结构，并返回一个 epfd;
+ epoll_ctl (int epfd, int op, struct poll_event* event): 将被监听的描述符添加到红黑树或者从红黑树中删除或者对监听的事件进行修改
+ epoll_wait (int epfd, struct epoll_event* events, int maxevents, int timeout): 阻塞等待注册的事件发生，返回事件的数目，并将触发的事件写入 events 数组中

## Epoll 两种触发机制：

+ 水平触发（LT）: 缓存区只要有数据才触发读写，epoll 的默认工作方式，select/poll 只支持这种方式。
+ 边缘触发（ET）: 缓存区空或满的状态才触发读写，nginx 使用该方式，避免频繁的读写操作。

## 惊群效应 ：

当多个进程/线程调用 epoll_wait 会阻塞等待，当内核触发可读写事件，所有进程/线程会进行响应，但是实际上只有一个进程/线程真实处理这些事件。Linux 4.5 引入 EPOLLEXCLUSIVE 标识来保证一个事件发生的时候只有一个线程会被唤醒，可以避免多侦听下的惊群问题。

# IO_Uring

Linux AIO 实现的并不理想，所以引入了新的异步 IO 接口 io_uring.
`io_uring` 是Linux下的一种新的异步IO机制，通过两种队列（提交队列和完成队列）在用户空间和内核之间高效地传递信息，从而减少系统调用的开销。

![Pasted image 20240715073156.png](/img/user/OS/assert/Pasted%20image%2020240715073156.png)

Io_uring 接口通过两个主要数据机构工作：
+ 提交队列的条目（sqe）
+ 完成队列的条目（cqe）

这些结构的实例位于内核和应用程序之间的**共享内存**单生产者单消费者环形缓存区中。

## 事件驱动编程模型

由于处理 IO 复用的编程模型比较复杂，简化编程，引入了下面两种模型：

+ Reactor（反应器）模式，对应于同步 IO, 被动的事件分离和分发模型。服务等待请求事件的到来，再通过不受间断的同步处理事件，从而做出反应。
+ Preactor (主动器) 模式，对应于异步 IO, 主动的事件分离和分发模型。这种设计允许多个任务并发的执行，从而提高吞吐量，并可执行耗时长的任务（各个人物间互不影响）。

Reactor模式适用于同步IO，依赖于事件循环和回调机制处理事件。
Proactor模式则对应于异步IO，允许并发执行多个操作，提高了应用性能。

## Reactor 模型

Reactor 模型是一种事件驱动的编程模式，广泛应用于网络服务中以处理并发连接和请求。此模型通过单个或多个线程有效地管理多个网络连接的事件，比如数据的接收和发送。它允许应用程序以非阻塞的方式进行通信，优化资源使用并提高应用性能。

![Pasted image 20240715074048.png](/img/user/OS/assert/Pasted%20image%2020240715074048.png)

#### 三种实现方式 ：

1. **单线程模式**：在此模式中，所有的 I/O 操作（accept, read, write, connect）都在同一个线程中处理。这种方式简单易理解，但可能在高负载下成为性能瓶颈。
2. **工作者线程池模式**：此模式下，主线程负责 I/O 操作，而耗时的非 I/O 任务则交由后台工作者线程池处理。这种分离提高了处理效率和响应速度。
3. **多线程模式**：在多线程模式中，主 Reactor（master）负责处理所有网络的监听事件，而多个子 Reactor（worker）则并行处理数据的读写。这种模式适合于高并发环境，可以显著提高程序的扩展性和响应性。

#### 读写操作流程 ：

1.  应用程序首先注册各种读写就绪事件及其相关的事件处理器。
2. 同步事件多路分离器（例如 select、poll 或 epoll）开启事件循环，监控并等待事件的发生。
3. 一旦检测到读写就绪事件，事件分离器便激活并调用之前注册的事件处理器。
4. 事件处理器随后执行具体的读写操作。

#### 参与者 ：

**描述符（Handle）**：是一个标识符，由操作系统提供，用于识别资源如套接字（sockets）。
**同步事件多路分离器**：是核心组件，负责开启事件循环，监测并响应各种IO事件。封装了多路复用函数 select/poll/epoll 等。
**事件处理器（Event Handler）**：提供回调函数，这些函数定义了如何处理特定的事件。
**具体的事件处理器**：是事件处理器接口的具体实现，用于处理通过描述符标识的事件。
**Reactor 管理器**：作为调度中心，负责事件的分发和事件处理器的调度，确保适当的处理程序被触发。。