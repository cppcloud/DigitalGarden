---
{"dg-publish":true,"permalink":"/CPP/条件变量/","tags":["cpp"]}
---



在多线程编程中，常常需要线程间同步，条件变量（`condition_variable`）就是其中一种常见机制。

#### 例子1：使用条件变量

```cpp
#include <iostream>
#include <condition_variable>
#include <mutex>
#include <thread>

std::mutex mutex_;
std::condition_variable condVar;
bool dataReady{false};

void doTheWork(){
    std::cout << "Processing shared data." << std::endl;
}

void waitingForWork(){
    std::cout << "Worker: Waiting for work." << std::endl;
    std::unique_lock<std::mutex> lck(mutex_);
    condVar.wait(lck, []{ return dataReady; });
    doTheWork();
    std::cout << "Work done." << std::endl;
}

void setDataReady(){
    {
        std::lock_guard<std::mutex> lck(mutex_);
        dataReady = true;
    }
    std::cout << "Sender: Data is ready." << std::endl;
    condVar.notify_one();
}

int main(){
    std::thread t1(waitingForWork);
    std::thread t2(setDataReady);
    t1.join();
    t2.join();
}
```

### 代码解析

这个程序创建了两个子线程 `t1` 和 `t2`。`t1` 执行 `waitingForWork` 函数，它会等待数据准备好；`t2` 执行 `setDataReady` 函数，负责设置数据状态并通知 `t1`。

#### `waitingForWork` 函数

1. **等待工作信号**: 输出 "Waiting for work."
2. **加锁**: 使用 `std::unique_lock` 锁定 `mutex_`。
3. **等待条件变量**:
    - 第一次调用 `wait` 时：加锁并检查条件 `dataReady` 是否为 `true`。
        - 如果 `true`，则解锁继续执行。
        - 如果 `false`，则解锁并进入等待状态。
    - 再次调用 `wait` 时：收到通知后加锁并检查条件 `dataReady`。
        - 如果 `true`，则解锁继续执行。
        - 如果 `false`，则解锁并重新进入等待状态。
4. **处理工作**: 调用 `doTheWork` 函数，输出 "Processing shared data."
5. **工作完成**: 输出 "Work done."

#### `setDataReady` 函数

1. **加锁**: 使用 `std::lock_guard` 锁定 `mutex_`。
2. **设置数据状态**: 将 `dataReady` 设置为 `true`。
3. **解锁并通知**: 解锁互斥量并调用 `notify_one` 通知等待线程。
4. **输出数据准备好**: 输出 "Sender: Data is ready."

### 使用谓词的重要性

如果没有谓词，等待调用可能会因以下现象导致问题：
- **丢失唤醒（Lost Wakeup）**：如果通知在线程开始等待之前进行，等待线程会错过通知信号。
- **虚假唤醒（Spurious Wakeup）**：线程可能被无故唤醒。

### 例子2：无谓词的情况

```cpp
// conditionVariableBlock.cpp

#include <iostream>
#include <condition_variable>
#include <mutex>
#include <thread>

std::mutex mutex_;
std::condition_variable condVar;
bool dataReady{false};

void waitingForWork(){
    std::cout << "Worker: Waiting for work." << std::endl;
    std::unique_lock<std::mutex> lck(mutex_);
    condVar.wait(lck);   // 没有谓词
    // 实际执行的工作
    std::cout << "Work done." << std::endl;
}

void setDataReady(){
    std::cout << "Sender: Data is ready." << std::endl;
    condVar.notify_one();
}

int main(){
    std::thread t1(setDataReady);
    std::thread t2(waitingForWork);
    t1.join();
    t2.join();
}
```

在这个例子中，去掉了谓词。第一次运行时看似正常，但如果 `notify_one` 在 `t2` 进入等待之前调用，则 `t2` 会一直等待，不会结束。这就是**丢失唤醒**现象。

### 详细解释条件变量等待流程

#### 初次进入等待

1. **加锁**: 调用 `wait` 方法时，首先加锁互斥量。
2. **检查谓词**: 检查谓词（或者条件）是否为 `true`。
    - 如果谓词为真，解锁并继续执行。
    - 如果谓词为假，解锁互斥量并进入等待状态。

#### 收到通知

1. **唤醒后加锁**: 当条件变量收到 `notify_one` 或 `notify_all` 通知，重新加锁互斥量。
2. **再次检查谓词**: 检查谓词是否为 `true`。
    - 如果谓词为真，解锁并继续执行。
    - 如果谓词为假，解锁互斥量并重新进入等待状态。
